# Lesson 1 : Blockchain

## Apa itu Blockcahin?

### Satoshi Nakamoto
Satoshi Nakamoto adalah nama yang digunakan oleh orang atau orang yang diduga sebagai pseudonim  yang mengembangkan bitcoin , menulis buku putih bitcoin , dan membuat serta menerapkan implementasi referensi asli bitcoin . 
### Perkembangan bitcoin
Nakamoto menyatakan bahwa penulisan kode untuk bitcoin dimulai pada tahun 2007. [10] Pada tanggal 18 Agustus 2008, dia atau rekannya mendaftarkan nama domain bitcoin.org, [11] dan membuat situs web di alamat tersebut. Pada tanggal 31 Oktober, Nakamoto menerbitkan buku putih di milis kriptografi di metzdowd.com yang menjelaskan tentang cryptocurrency digital , berjudul "Bitcoin: A Peer-to-Peer Electronic Cash System". Nakamoto terus berkolaborasi dengan pengembang lain pada perangkat lunak bitcoin hingga pertengahan 2010, membuat semua modifikasi pada kode sumbernya sendiri. Dia kemudian memberikan kendali atas repositori kode sumber dan kunci peringatan jaringan kepada Gavin Andresen , [22] mentransfer beberapa domain terkait ke berbagai anggota terkemuka komunitas bitcoin, dan menghentikan keterlibatannya yang diakui dalam proyek tersebut. Pada tahun 2016, Financial Times mengatakan bahwa Nakamoto mungkin adalah sekelompok orang, menyebutkan Hal Finney, Nick Szabo, dan Adam Back sebagai anggota potensial. [73] Pada tahun 2020, saluran YouTube Barely Sociable mengklaim bahwa Adam Back, penemu bitcoin pendahulunya Hashcash , adalah Nakamoto. [74] Kembali kemudian membantah ini. [75]

### Bitcoin
Perdagangan di Internet hampir sepenuhnya bergantung pada lembaga keuangan yang berfungsi sebagai pihak ketiga tepercaya untuk memproses pembayaran elektronik. Sementara sistem bekerja cukup baik untuk sebagian besar transaksi, masih menderita kelemahan yang melekat pada model berbasis kepercayaan. Transaksi yang sepenuhnya tidak dapat dibalikkan tidak benar-benar mungkin, karena lembaga keuangan tidak dapat menghindari mediasi perselisihan. Biaya mediasi meningkatkan biaya transaksi, membatasi ukuran transaksi praktis minimum dan memotong kemungkinan untuk transaksi kasual kecil, dan ada biaya yang lebih besar dalam hilangnya kemampuan untuk melakukan pembayaran yang tidak dapat dikembalikan untuk layanan yang tidak dapat dikembalikan. Dengan kemungkinan pembalikan, kebutuhan akan kepercayaan menyebar. Pedagang harus waspada terhadap pelanggan mereka, mengganggu mereka untuk mendapatkan lebih banyak informasi daripada yang mereka butuhkan. Persentase penipuan tertentu diterima sebagai hal yang tidak dapat dihindari. Biaya dan ketidakpastian pembayaran ini dapat dihindari secara langsung dengan menggunakan mata uang fisik, tetapi tidak ada mekanisme untuk melakukan pembayaran melalui saluran komunikasi tanpa pihak yang dipercaya. 
Kami mendefinisikan koin elektronik sebagai rantai tanda tangan digital. Setiap pemilik mentransfer koin ke selanjutnya dengan menandatangani hash dari transaksi sebelumnya dan kunci publik pemilik berikutnya secara digital dan menambahkan ini ke akhir koin. Penerima pembayaran dapat memverifikasi tanda tangan untuk memverifikasi rantai kepemilikan. 
Masalahnya tentu saja penerima pembayaran tidak dapat memverifikasi bahwa salah satu pemilik tidak melakukan pembelanjaan ganda koin. Solusi umum adalah memperkenalkan otoritas pusat tepercaya, atau mint, yang memeriksa setiap transaksi untuk pembelanjaan ganda. Setelah setiap transaksi, koin harus dikembalikan ke mint untuk mengeluarkan koin baru, dan hanya koin yang dikeluarkan langsung dari mint yang dipercaya tidak dibelanjakan ganda. Masalah dengan solusi ini adalah bahwa nasib seluruh sistem uang tergantung pada perusahaan menjalankan mint, dengan setiap transaksi harus melalui mereka, seperti bank. Kami membutuhkan cara agar penerima pembayaran mengetahui bahwa pemilik sebelumnya tidak menandatangani lebih awal transaksi. Untuk tujuan kami, transaksi paling awal adalah yang diperhitungkan, jadi kami tidak peduli tentang upaya selanjutnya untuk menghabiskan dua kali lipat. 

### Timestamp Server
Solusi yang kami usulkan dimulai dengan server cap waktu. Server cap waktu bekerja dengan mengambil hash dari blok item yang akan diberi stempel waktu dan mempublikasikan hash secara luas, seperti di surat kabar atau pos Usenet [2-5]. Stempel waktu membuktikan bahwa data pasti ada di waktu, jelas, untuk masuk ke hash. Setiap stempel waktu menyertakan stempel waktu sebelumnya di hashnya, membentuk rantai, dengan setiap stempel waktu tambahan memperkuat yang sebelumnya.

### Proof of Work
Untuk mengimplementasikan server timestamp terdistribusi secara peer-to-peer, kita perlu menggunakan sistem proof-of-work yang mirip dengan Hashcash Adam Back [6], daripada posting koran atau Usenet. Bukti kerja melibatkan pemindaian nilai yang ketika di-hash, seperti dengan SHA-256, nilai hash dimulai dengan sejumlah nol bit. Usaha rata-rata yang dibutuhkan adalah eksponensial dalam bilangan dari nol bit diperlukan dan dapat diverifikasi dengan mengeksekusi hash tunggal. Untuk jaringan timestamp kami, kami menerapkan proof-of-work dengan menambahkan nonce di blok sampai nilai ditemukan yang memberikan hash blok bit nol yang diperlukan. Untuk mengimbangi peningkatan kecepatan perangkat keras dan berbagai minat dalam menjalankan node dari waktu ke waktu, kesulitan proof-of-work ditentukan oleh rata-rata bergerak yang menargetkan jumlah rata-rata blok per jam. Jika mereka dihasilkan terlalu cepat, kesulitannya meningkat.

### Incentive
Secara konvensi, transaksi pertama di blok adalah transaksi khusus yang memulai koin baru yang dimiliki oleh pembuat blok. Ini menambah insentif bagi node untuk mendukung jaringan, dan menyediakan cara untuk awalnya mendistribusikan koin ke dalam sirkulasi, karena tidak ada otoritas pusat untuk mengeluarkannya. Penambahan konstan jumlah koin baru yang konstan analog dengan pengeluaran penambang emas sumber daya untuk menambahkan emas ke sirkulasi. Dalam kasus kami, waktu CPU dan listrik yang dikeluarkan. Insentif juga dapat didanai dengan biaya transaksi. Jika nilai keluaran dari suatu transaksi adalah kurang dari nilai inputnya, selisihnya adalah biaya transaksi yang ditambahkan ke nilai insentif blok yang berisi transaksi. Setelah jumlah koin yang telah ditentukan telah masuk sirkulasi, insentif dapat beralih sepenuhnya ke biaya transaksi dan sepenuhnya menjadi inflasi Gratis. Insentif dapat membantu mendorong node untuk tetap jujur. Jika penyerang serakah mampu mengumpulkan lebih banyak daya CPU daripada semua node yang jujur, dia harus memilih antara menggunakannya untuk menipu orang dengan mencuri kembali pembayarannya, atau menggunakannya untuk menghasilkan koin baru. 

### Verifikasi Pembayaran Sederhana
Dimungkinkan untuk memverifikasi pembayaran tanpa menjalankan node jaringan penuh. Seorang pengguna hanya perlu menyimpan salinan tajuk blok dari rantai proof-of-work terpanjang, yang bisa dia dapatkan dengan menanyakan node jaringan sampai dia yakin dia memiliki rantai terpanjang, dan mendapatkan cabang Merkle menautkan transaksi ke blok yang diberi cap waktu. Dia tidak dapat memeriksa transaksi untuk sendiri, tetapi dengan menghubungkannya ke suatu tempat dalam rantai, dia dapat melihat bahwa simpul jaringan telah menerimanya, dan blok ditambahkan setelah konfirmasi lebih lanjut bahwa jaringan telah menerimanya.

### Privasi
Model perbankan tradisional mencapai tingkat privasi dengan membatasi akses informasi ke pihak yang terlibat dan pihak ketiga yang dipercaya. Keharusan untuk mengumumkan semua transaksi secara public menghalangi metode ini, tetapi privasi masih dapat dipertahankan dengan memutus aliran informasi di tempat lain: dengan menjaga kunci publik tetap anonim. Publik dapat melihat bahwa seseorang mengirim sejumlah uang kepada orang lain, tetapi tanpa informasi yang menghubungkan transaksi tersebut kepada siapa pun. Ini adalah serupa dengan tingkat informasi yang dikeluarkan oleh bursa, di mana waktu dan ukuran perdagangan individu, "pita", dipublikasikan, tetapi tanpa memberi tahu siapa pihak-pihak itu. Sebagai firewall tambahan, pasangan kunci baru harus digunakan untuk setiap transaksi untuk menjaganya dari yang terkait dengan pemilik umum. Beberapa penautan masih tidak dapat dihindari dengan multi-input transaksi, yang dengan sendirinya mengungkapkan bahwa input mereka dimiliki oleh pemilik yang sama. Risikonya adalah bahwa jika pemilik kunci terungkap, penautan dapat mengungkapkan transaksi lain yang dimiliki pemilik yang sama.

